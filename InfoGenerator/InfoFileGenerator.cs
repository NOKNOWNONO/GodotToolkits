using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Text.Json;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Diagnostics;

namespace InfoGenerator;

[Generator]
public sealed class InfoFileGenerator : IIncrementalGenerator
{
	private string _configText = "";
	private string _rootPath = "";

	public static string GeneratedTitle(
		string generator,
		string version,
		DateTime time
	)
	{
		return $@"// <auto-generated>
//     Generated by {generator} {version} on {time:yyyy-MM-dd HH:mm:ss}.
// </auto-generated>
";
	}

	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		var config = context.AnalyzerConfigOptionsProvider;

		context.RegisterImplementationSourceOutput(config, GetConfig);

		context.RegisterSourceOutput(config, GenerateCode);
	}

	private void GenerateCode(
		SourceProductionContext context,
		AnalyzerConfigOptionsProvider options
	)
	{
		if (_configText == "")
			return;
		var config = JsonSerializer.Deserialize<InfoConfig>(_configText);
		if (config == null)
			return;
		var code = BuildInfoConfig(_rootPath, config);
		if (string.IsNullOrEmpty(code))
			return;
		var outputPath = Path.Combine(_rootPath, config.OutputPath);
		using FileStream stream = new(
			outputPath,
			FileMode.Create,
			FileAccess.Write
		);
		using StreamWriter writer = new(stream, Encoding.UTF8);
		writer.Write(code);
	}

	private string BuildInfoConfig(string rootPath, InfoConfig config)
	{
		var code = new StringBuilder();
		code.AppendLine(
			GeneratedTitle(nameof(InfoGenerator), "0", DateTime.Now)
		);
		if (!string.IsNullOrEmpty(config.NameSpace))
			code.AppendLine($"namespace {config.NameSpace};");
		code.AppendLine();
		code.AppendLine($"public static class {config.Name} {{");
		foreach (var property in config.Properties)
		{
			code.AppendLine(
				$"\t{BuildPropertyInfo(rootPath, property, config.Targets)}"
			);
		}

		code.AppendLine("}");
		return code.ToString();
	}

	private string BuildPropertyInfo(
		string rootPath,
		PropertyInfo property,
		Dictionary<string, TargetInfo> targets
	)
	{
		var code = new StringBuilder();
		code.Append($"public const {property.Type} {property.Name} = ");
		if (property.Value.StartsWith("$"))
		{
			var target = targets[property.Value.Substring(1)];
			code.Append(BuildParseTargetInfo(rootPath, target));
		}
		else
		{
			code.Append(property.Value);
		}

		code.AppendLine(";");
		return code.ToString();
	}

	private string BuildParseTargetInfo(string rootPath, TargetInfo target)
	{
		return $"\"{TargetInfoParser.Parse(rootPath, target)}\"";
	}

	private void GetConfig(
		SourceProductionContext context,
		AnalyzerConfigOptionsProvider options
	)
	{
		if (
			!options.GlobalOptions.TryGetValue(
				"build_property.projectdir",
				out var projectDir
			)
		)
			return;

		_rootPath = projectDir;

		var configPath = Path.Combine(projectDir, "Info.json");

		try
		{
			_configText = FileReader.ReadFile(configPath);
		}
		catch (FileNotFoundException fileNotFoundException)
		{
			Console.WriteLine(
				$"Config file not found: {fileNotFoundException.Message}"
			);
		}
		catch (Exception e)
		{
			Console.WriteLine(e);
		}
	}
}
